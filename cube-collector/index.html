<!DOCTYPE html>
<html>
<head>
    <title>Cube Collector</title>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background: #000; }
        #score { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; font-size: 20px; z-index: 1; }
        #modeSelect { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: Arial; font-size: 24px; z-index: 1; text-align: center; }
        #comboIndicator { position: absolute; color: yellow; font-family: Arial; font-size: 16px; z-index: 1; display: none; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="modeSelect">
        <p>Select Mode:</p>
        <button onclick="startGame('free')">Free Play</button>
        <button onclick="startGame('timed')">Timed (60s)</button>
        <button onclick="startGame('endurance')">Endurance</button>
    </div>
    <div id="comboIndicator"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add ambient light for emissive
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);

        const starGeometry = new THREE.BufferGeometry();
        const starCount = 500;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount * 3; i++) starPositions[i] = (Math.random() - 0.5) * 50;
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        const borderGeometry = new THREE.BoxGeometry(20, 16, 0.1);
        const borderMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
        const border = new THREE.Mesh(borderGeometry, borderMaterial);
        scene.add(border);

        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(0, 0, 0);
        scene.add(player);

        const dustParticles = [];
        const dustGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const dustMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });

        const orbs = [];
        let score = 0, lastCollectTime = 0, combo = 0, penaltyChance = 0.2;
        let dashCooldown = 0, dashDuration = 0;
        const scoreDisplay = document.getElementById('score');
        const comboIndicator = document.getElementById('comboIndicator');
        function addOrb(isPenalty = false) {
            const orbGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            let color;
            if (isPenalty) {
                color = 0x666666; // Gray for penalty
            } else {
                do {
                    color = Math.random() * 0xffffff;
                } while (color > 0xaaaaaa && color < 0x555555); // Avoid gray shades
            }
            const orbMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: isPenalty ? 0xff0000 : 0x333333,
                emissiveIntensity: isPenalty ? 3 : 1 // Strong red glow
            });
            const orb = new THREE.Mesh(orbGeometry, orbMaterial);
            const aspect = window.innerWidth / window.innerHeight;
            const xRange = aspect < 1 ? 8 : 18;
            orb.position.set(
                (Math.random() - 0.5) * xRange,
                (Math.random() - 0.5) * 14,
                0
            );
            orb.userData = { 
                isPenalty, 
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02, 0),
                life: isPenalty ? 300 : Infinity
            };
            scene.add(orb);
            orbs.push(orb);
        }
        function maintainOrbs() {
            while (orbs.length < 3) addOrb();
            if (orbs.length < 4 && Math.random() < penaltyChance) addOrb(true);
        }
        for (let i = 0; i < 3; i++) addOrb();
        if (Math.random() < penaltyChance) addOrb(true);

        function updateCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            if (aspect < 1) { camera.fov = 45; camera.position.set(0, 5, 30); }
            else { camera.fov = 75; camera.position.set(0, 5, 15); }
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            camera.lookAt(0, 0, 0);
        }
        updateCamera();

        const keys = {};
        let touchStartX = null, touchStartY = null, moveX = 0, moveY = 0;
        let gameMode = null, timeLeft = 60;

        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);
        document.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            e.preventDefault();
        }, { passive: false });
        document.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const aspect = window.innerWidth / window.innerHeight;
            const speedMultiplier = aspect < 1 ? 0.07 : 0.1;
            moveX = deltaX * speedMultiplier;
            moveY = -deltaY * speedMultiplier;
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            e.preventDefault();
        }, { passive: false });
        document.addEventListener('touchend', () => { moveX = 0; moveY = 0; touchStartX = null; touchStartY = null; });

        function startGame(mode) {
            gameMode = mode;
            document.getElementById('modeSelect').style.display = 'none';
            if (mode === 'timed') timeLeft = 60;
            if (mode === 'endurance') penaltyChance = 0.2;
            animate();
        }

        function showCombo(points, x, y) {
            comboIndicator.textContent = `+${points}`;
            comboIndicator.style.left = `${x + window.innerWidth / 2}px`;
            comboIndicator.style.top = `${y + window.innerHeight / 2}px`;
            comboIndicator.style.display = 'block';
            setTimeout(() => comboIndicator.style.display = 'none', 500);
        }

        function animate() {
            if (!gameMode) return;
            requestAnimationFrame(animate);
            const speed = dashDuration > 0 ? 0.5 : 0.1;
            const now = Date.now();

            if (keys['ArrowUp']) player.position.y += speed;
            if (keys['ArrowDown']) player.position.y -= speed;
            if (keys['ArrowLeft']) player.position.x -= speed;
            if (keys['ArrowRight']) player.position.x += speed;
            if ((keys[' '] || keys['Space']) && dashCooldown <= 0) { // Check both
                console.log('Dash triggered');
                dashDuration = 30;
                dashCooldown = 120;
            }
            player.position.x += moveX;
            player.position.y += moveY;
            player.position.x = Math.max(-10, Math.min(10, player.position.x));
            player.position.y = Math.max(-8, Math.min(8, player.position.y));

            dashDuration = Math.max(0, dashDuration - 1);
            dashCooldown = Math.max(0, dashCooldown - 1);

            player.scale.set(1 + 0.1 * Math.sin(now * 0.005), 1 + 0.1 * Math.sin(now * 0.005), 1 + 0.1 * Math.sin(now * 0.005));

            if (dustParticles.length < 10) {
                const dust = new THREE.Mesh(dustGeometry, dustMaterial);
                dust.position.copy(player.position);
                scene.add(dust);
                dustParticles.push({ mesh: dust, life: 30 });
            }
            dustParticles.forEach((p, i) => {
                p.life--;
                p.mesh.position.z -= 0.05;
                if (p.life <= 0) { scene.remove(p.mesh); dustParticles.splice(i, 1); }
            });

            if (score >= 100) playerMaterial.color.set(0xff00ff);
            else if (score >= 50) playerMaterial.color.set(0x0000ff);
            else playerMaterial.color.set(0x00ff00);

            orbs.forEach(orb => {
                orb.position.add(orb.userData.velocity);
                if (orb.position.x > 9 || orb.position.x < -9) orb.userData.velocity.x *= -1;
                if (orb.position.y > 7 || orb.position.y < -7) orb.userData.velocity.y *= -1;
                orb.position.z = 0;
                if (orb.userData.isPenalty) {
                    orb.userData.life--;
                    if (orb.userData.life <= 0) {
                        scene.remove(orb);
                        orbs.splice(orbs.indexOf(orb), 1);
                        maintainOrbs();
                    }
                }
            });

            for (let i = orbs.length - 1; i >= 0; i--) {
                const distance = player.position.distanceTo(orbs[i].position);
                if (distance < 1.5) {
                    scene.remove(orbs[i]);
                    const wasPenalty = orbs[i].userData.isPenalty;
                    const orbX = orbs[i].position.x, orbY = orbs[i].position.y;
                    orbs.splice(i, 1);
                    if (wasPenalty) {
                        score -= 20;
                        combo = 0;
                        showCombo(-20, orbX, orbY);
                    } else {
                        const timeSinceLast = (now - lastCollectTime) / 1000;
                        const points = timeSinceLast < 2 ? 10 + combo * 5 : 10;
                        score += points;
                        combo = timeSinceLast < 2 ? combo + 1 : 0;
                        lastCollectTime = now;
                        showCombo(points, orbX, orbY);
                    }
                    scoreDisplay.textContent = `Score: ${score}`;
                    maintainOrbs();
                }
            }

            if (gameMode === 'timed') {
                timeLeft -= 1 / 60;
                if (timeLeft <= 0) {
                    alert(`Game Over! Score: ${score}`);
                    gameMode = null;
                    document.getElementById('modeSelect').style.display = 'block';
                }
                scoreDisplay.textContent = `Score: ${score} | Time: ${Math.ceil(timeLeft)}s`;
            } else if (gameMode === 'endurance') {
                penaltyChance = Math.min(0.5, penaltyChance + 0.005);
                scoreDisplay.textContent = `Score: ${score} | Penalty: ${(penaltyChance * 100).toFixed(0)}%`;
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateCamera();
        });
    </script>
</body>
</html>
