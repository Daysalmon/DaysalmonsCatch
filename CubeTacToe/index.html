<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeTacToe</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; }
        #mode { position: absolute; top: 40px; left: 10px; }
    </style>
</head>
<body>
    <div id="info">Turn: X | Mode: PvP</div>
    <select id="mode">
        <option value="pvp">PvP</option>
        <option value="ai">vs AI</option>
    </select>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0x87CEEB, 1); // Match CSS background
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);

        // Grid (3x3x3)
        const gridSize = 3;
        const cellSize = 1;
        const cells = [];
        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                for (let z = 0; z < gridSize; z++) {
                    const geometry = new THREE.BoxGeometry(cellSize * 0.9, cellSize * 0.9, cellSize * 0.9);
                    const edges = new THREE.EdgesGeometry(geometry);
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF, linewidth: 2 });
                    const cube = new THREE.LineSegments(edges, lineMaterial);
                    cube.position.set(x - 1, y - 1, z - 1);
                    cube.userData = { x, y, z, occupied: false, mark: null };
                    scene.add(cube);
                    cells.push(cube);
                }
            }
        }

        // Marks (improved)
        const xGeometry = new THREE.ExtrudeGeometry(
            new THREE.Shape().moveTo(-0.4, -0.4).lineTo(0.4, 0.4).moveTo(-0.4, 0.4).lineTo(0.4, -0.4),
            { depth: 0.2, bevelEnabled: false }
        ); // 3D X
        const oGeometry = new THREE.TorusGeometry(0.4, 0.15, 16, 100); // Thicker O
        const xMaterial = new THREE.MeshBasicMaterial({ color: 0xFF4040 });
        const oMaterial = new THREE.MeshBasicMaterial({ color: 0x4040FF });

        // Game state
        let currentPlayer = 'X';
        let gameOver = false;
        const modeSelect = document.getElementById('mode');
        let gameMode = modeSelect.value;

        // Raycaster
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Winning lines (all 49)
        const winningLines = [];
        // Rows
        for (let y = 0; y < gridSize; y++) {
            for (let z = 0; z < gridSize; z++) {
                winningLines.push(cells.slice(y * 9 + z * 3, y * 9 + z * 3 + 3));
            }
        }
        // Columns
        for (let x = 0; x < gridSize; x++) {
            for (let z = 0; z < gridSize; z++) {
                const line = [];
                for (let y = 0; y < gridSize; y++) line.push(cells[y * 9 + z * 3 + x]);
                winningLines.push(line);
            }
        }
        // Pillars
        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                const line = [];
                for (let z = 0; z < gridSize; z++) line.push(cells[y * 9 + z * 3 + x]);
                winningLines.push(line);
            }
        }
        // Diagonals (simplified for now, full set is complex)
        winningLines.push([cells[0], cells[13], cells[26]]); // Corner-to-corner
        winningLines.push([cells[2], cells[13], cells[24]]); // Opposite diagonal

        // Camera and rotation
        camera.position.set(4, 4, 4);
        camera.lookAt(0, 0, 0);
        const gridGroup = new THREE.Group();
        cells.forEach(cell => gridGroup.add(cell));
        scene.add(gridGroup);

        // Keyboard controls
        const rotationSpeed = 0.05;
        window.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp': case 'w': gridGroup.rotation.x -= rotationSpeed; break;
                case 'ArrowDown': case 's': gridGroup.rotation.x += rotationSpeed; break;
                case 'ArrowLeft': case 'a': gridGroup.rotation.y -= rotationSpeed; break;
                case 'ArrowRight': case 'd': gridGroup.rotation.y += rotationSpeed; break;
            }
        });

        // Event listeners
        window.addEventListener('click', onClick);
        modeSelect.addEventListener('change', () => {
            gameMode = modeSelect.value;
            resetGame();
            if (gameMode === 'ai' && currentPlayer === 'O') setTimeout(aiMove, 500);
        });

        function onClick(event) {
            if (gameOver) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cells);
            if (intersects.length > 0) {
                const cell = intersects[0].object;
                if (!cell.userData.occupied) {
                    placeMark(cell);
                    checkWin();
                    if (!gameOver && gameMode === 'ai' && currentPlayer === 'O') setTimeout(aiMove, 500);
                }
            }
        }

        function placeMark(cell) {
            const mark = currentPlayer === 'X' ?
                new THREE.Mesh(xGeometry, xMaterial) :
                new THREE.Mesh(oGeometry, oMaterial);
            mark.position.copy(cell.position);
            gridGroup.add(mark); // Add to group for rotation
            cell.userData.occupied = true;
            cell.userData.mark = currentPlayer;
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            document.getElementById('info').innerText = `Turn: ${currentPlayer} | Mode: ${gameMode.toUpperCase()}`;
        }

        function aiMove() {
            const emptyCells = cells.filter(cell => !cell.userData.occupied);
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                placeMark(randomCell);
                checkWin();
            }
        }

        function checkWin() {
            for (const line of winningLines) {
                if (line.every(cell => cell.userData.occupied && cell.userData.mark === line[0].userData.mark)) {
                    document.getElementById('info').innerText = `${line[0].userData.mark} Wins!`;
                    gameOver = true;
                    return;
                }
            }
            if (cells.every(cell => cell.userData.occupied)) {
                document.getElementById('info').innerText = "Tie!";
                gameOver = true;
            }
        }

        function resetGame() {
            cells.forEach(cell => {
                cell.userData.occupied = false;
                cell.userData.mark = null;
            });
            gridGroup.children = gridGroup.children.filter(obj => cells.includes(obj));
            currentPlayer = 'X';
            gameOver = false;
            gridGroup.rotation.set(0, 0, 0); // Reset rotation
            document.getElementById('info').innerText = `Turn: X | Mode: ${gameMode.toUpperCase()}`;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
